package sm2

import (
	"crypto/elliptic"
	"encoding/asn1"
	"errors"
	"github.com/hyperchain/gosdk/common"
	"github.com/hyperchain/gosdk/utils/encrypt/guomi"
	gmx509 "github.com/hyperchain/gosdk/utils/encrypt/guomi/sm2/x509"
	"math/big"
)

var (
	oidNamedCurveP256Sm2 = asn1.ObjectIdentifier{1, 2, 156, 10197, 1, 301}
)

//The private key generated by gmssl is slightly different from the private key of cfca
// so there are two similar structures, sm2PrivateKeyCFCA and sm2PrivateKeyGmssl
type sm2PrivateKeyCFCA struct {
	Version       int
	PrivateKey    *big.Int
	NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
	PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
}

type sm2PrivateKeyGmssl struct {
	Version       int
	PrivateKey    asn1.RawContent
	NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
	PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
}

//ParseSMPrivateKey Parse guomi private key, support gmssl private key and cfca private key
// return the gmx509.PrivateKey type.
// first try to resolve to the private key of type gmssl.
// if it fails, try to resolve to the private key of cfca.
func ParseSMPrivateKey(der []byte) (interface{}, error) {
	var privGmssl sm2PrivateKeyGmssl
	var privCFCA sm2PrivateKeyCFCA
	_, err := asn1.Unmarshal(der, &privGmssl)
	//if err is nil, parsing is successful
	if err == nil {
		if !privGmssl.NamedCurveOID.Equal(oidNamedCurveP256Sm2) {
			return nil, errors.New("is not SM Private key")
		}
		x, y := elliptic.Unmarshal(guomi.P256Sm2(), privGmssl.PublicKey.Bytes)
		return &gmx509.PrivateKey{
			PublicKey: gmx509.PublicKey{
				Curve: guomi.P256Sm2(),
				X:     x,
				Y:     y,
			},
			D: common.BytesToBig(privGmssl.PrivateKey),
		}, nil
	}

	err = nil
	_, err = asn1.Unmarshal(der, &privCFCA)
	//if err is nil, parsing is successful
	if err == nil {
		if !privCFCA.NamedCurveOID.Equal(oidNamedCurveP256Sm2) {
			return nil, errors.New("is not SM Private key")
		}
		x, y := elliptic.Unmarshal(guomi.P256Sm2(), privCFCA.PublicKey.Bytes)
		return &gmx509.PrivateKey{
			PublicKey: gmx509.PublicKey{
				Curve: guomi.P256Sm2(),
				X:     x,
				Y:     y,
			},
			D: privCFCA.PrivateKey,
		}, nil
	}

	return nil, errors.New("is not SM Private key")
}

//// SM2Sign sign a msg by SM3.
//func SM2Sign(key *gmx509.PrivateKey, msg []byte) ([]byte, error) {
//	digest := guomi.SignHashSM3(common.BigToBytes(key.X, 10), common.BigToBytes(key.Y, 10), msg)
//	return key.Sign(nil, digest, nil)
//}
//
//// SM2Verify verifies signature by SM3.
//func SM2Verify(pub *gmx509.PublicKey, msg, signature []byte) (bool, error) {
//	temp := guomi.PublicKey{
//		Curve: 0,
//		X:     common.BigToBytes(pub.X, 10),
//		Y:     common.BigToBytes(pub.Y, 10),
//	}
//	digest := guomi.SignHashSM3(temp.X, temp.Y, msg)
//	return temp.VerifySignature(signature, digest)
//}
